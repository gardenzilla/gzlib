syntax = "proto3";
package upl;
import "prelude.proto";
import "google/protobuf/empty.proto";

service Reservation {
  rpc SetReservation(ReservationRequest) returns (ReservationResponse);
}

service Upl {
  // Create new UPL
  // Just from a procurement or inventory service!
  // No public API should be implemented!
  rpc CreateNew(e) returns (UplObj);
  // Get UPL by ID
  rpc GetById(e) returns (UplObj);
  // Get UPLs by Sku
  rpc GetBySku(e) returns (stream UplObj);
  // Get UPLs by Sku and Location
  rpc GetBySkuAndLocation(e) returns (stream UplObj);
  // Get UPLs by Location
  rpc GetByLocation(e) returns (stream UplObj);
  // Restore archived UPL to a given Stock
  // Should be two reason:
  //   1) Sold UPL is back for any reason
  //   2) Discarded(Missing) product is back
  rpc RestoreToStock(e) returns (UplObj);
  // Modify best before date
  // This should not use at all
  // As this info should be correctly provided by
  // the procurement process
  // The only possible usage to correct a bestbefore date
  // error during inventory check.
  rpc SetBestBefore(e) returns (UplObj);
  // Split one UPL from BulkUpl
  rpc Split(e) returns (UplObj);
  // Divide divisible Upl or OpenedUpl into a smaller Upl
  rpc Divide(e) returns (UplObj);

  // TODO! Implement this
  // Merge an ancestor and a successor UPL into the ancestor
  // rpc Merge(e) returns (UplObj);

  // Put UPL to a Cart (Apply lock)
  rpc LockToCart(e) returns (UplObj);
  // Put UPL to a Delivery (Apply lock)
  rpc LockToDelivery(e) returns (UplObj);
  // Put UPL to an Inventory (Apply lock)
  rpc LockToInventory(e) returns (UplObj);
  // Checkout delivery UPLs to a given Stock(ID)
  // Close a cart (transform lock to location)
  rpc CloseCart(e) returns (e);
  // Close a delivery (transform lock to location)
  rpc CloseDelivery(e) returns (e);
  // Close an inventory (transform lock to location)
  rpc CloseInventory(e) returns (e);
  // Put UPLs from Delivery to a given Stock (MOVE)
  rpc CheckoutDelivery(e) returns (e);
  // Remove UPL from a Cart (Release lock)
  rpc ReleaseLockFromCart(e) returns (UplObj);
  // Remove UPL from a Delivery (Release lock)
  rpc ReleaseLockFromDelivery(e) returns (UplObj);
  // Remove UPL from an Inventory (Release lock)
  rpc ReleaseLockFromInventory(e) returns (UplObj);
  // Return a UPL history
  // todo! Implement history!
  // rpc GetHistory(e) returns (stream HistoryItem);
}

message e {}

message ReservationRequest {
  message Local {
    string cart_id = 1;
    string stock_id = 2;
    oneof Subject {
      uint32 sku = 3;
      uint32 divided_product = 4;
    }
    uint32 reserved_amount = 5;
  }
  message Global {
    string cart_id = 1;
    oneof Subject {
      uint32 sku = 2;
      uint32 divided_product = 3;
    }
    uint32 reserved_amount = 4;
  }
  oneof reservation {
    Local local = 1;
    Global global = 2;
  }
}

message ReservationResponse {
  message Local {
    string cart_id = 1;
    string stock_id = 2;
    oneof Subject {
      uint32 sku = 3;
      uint32 divided_product = 4;
    }
    uint32 reserved_amount = 5;
    uint32 taken_amount = 6;
  }
  message Global {
    string cart_id = 1;
    oneof Subject {
      uint32 sku = 2;
      uint32 divided_product = 3;
    }
    uint32 reserved_amount = 4;
    uint32 taken_amount = 5;
  }
  oneof reservation {
    Local local = 1;
    Global global = 2;
  }
}

message UplObj {
  enum UplKind {
    Sku = 0;
    BulkSku = 1;
    OpenedSku = 2;
    DerivedProduct = 3;
  }
  enum LockKind {
    CartLock = 0;
    DeliveryLock = 1;
    InventoryLock = 2;
    None = 3;
  }
  enum LocationKind {
    StockLocation = 0;
    CartLocation = 1;
    DeliveryLocation = 2;
    DiscardLocation = 3;
  }
  // UPL ID
  string id = 1;
  // Related product id
  uint32 product_id = 2;
  // Related SKU if there is any, otherwise 0
  uint32 sku = 3;
  // Represents how many UPL this unit contains
  // Can bigger then 1 if UplKind is Bulk
  // Otherwise always 1
  uint32 upl_piece = 4;
  // If UPL is healty: no depreciation, no best_before issue
  bool is_healty = 5;
  // If UplKind is DerivedProduct; this shows its ancestor
  uint32 derived_from = 6;
  // If UplKind is OpenedSku and there are successors (derived products from it)
  repeated uint32 upl_successors = 7;
  // Best before date (NaiveDate YYYY-MM-DD) if there is any
  string best_before = 8;
  // If there is any deprecation data
  bool is_depreciated = 9;
  // Deprecation id; only if depreciated
  uint32 depreciation_id = 10;
  // Deprecation comment; only if depreciated
  string depreciation_comment = 11;
  // Deprecation net price; only if depreciated
  uint32 depreciation_net_price = 12;
  // Procurement id
  uint32 procurement_id = 13;
  // Procurement net price
  uint32 procurement_net_price = 14;
  // Is it divisible? Only if SKU or Derived Product and is divisible
  bool is_divisible = 15;
  // Divisible amount; if divisible; otherwise 0
  uint32 divisible_amount = 16;
  // If there any applied lock
  bool is_locked = 17;
  // If locked; lock kind
  LockKind lock_kind = 18;
  // If locked; lock id
  uint32 lock_id = 19;
  // Location kind
  LocationKind location_kind = 20;
  // Location ID
  uint32 location_id = 21;
  // UPL kind
  UplKind upl_kind = 22;
  // If upl_kind is BULK ? true : false
  bool is_kind_bulk = 23;
  // If upl_kind is OpenedSku ? true : false
  bool is_kind_opened = 24;
  // If upl_kind is Sku ? true : false
  bool is_kind_original = 25;
  // If upl_kind is DerivedProduct ? true : false
  bool is_kind_derived = 26;
  // If upl is archived ? true : false
  bool is_archived = 27;
  // Created by user
  string created_by = 29;
  // Created at RFC3339
  string created_at = 30;
}